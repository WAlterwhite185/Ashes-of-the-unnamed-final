<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ashes of the Unnamed â€” FULL (CDN v3)</title>
<meta name="description" content="Retro-3D Gothic Action vertical slice. Iframe-friendly.">
<style>
  :root{
    --ui-bg: rgba(10,10,12,.78);
    --ui-fg: #e8e4dc;
    --ui-iron: #2a2a32;
    --hp: #b51f2a;
    --st: #6ea0c9;
    --mp: #79c06d;
    --gold: #c6a86a;
  }
  html,body{height:100%;margin:0;background:#0a0a0a;color:var(--ui-fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif;overflow:hidden}
  #root{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 50%,#151515 0%,#080808 60%)}
  /* 16:9 responsive stage */
  #stage{position:relative;width:100vw;height:56.25vw;max-width:177.78vh;max-height:100vh;background:#000;overflow:hidden;border:1px solid #1b1b1b;box-shadow:0 0 60px rgba(0,0,0,.65) inset}
  canvas{display:block;width:100%;height:100%;image-rendering:pixelated}
  /* HUD */
  #hud{position:absolute;inset:0;pointer-events:none}
  .ornate{position:absolute;inset:8px;border:2px solid #2b2b2b;box-shadow:0 0 0 2px rgba(0,0,0,.5) inset,0 0 18px rgba(0,0,0,.45) inset;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(0,0,0,.15))}
  .ornate:before,.ornate:after{content:"";position:absolute;width:64px;height:64px;background:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><path d="M4 60 Q 24 48 28 36 Q 36 24 60 4" stroke="%23c6a86a" stroke-width="2" fill="none" opacity=".35"/></svg>') no-repeat center / contain;filter:drop-shadow(0 0 2px rgba(0,0,0,.6))}
  .ornate:before{left:-8px;top:-8px}
  .ornate:after{right:-8px;bottom:-8px;transform:rotate(180deg)}

  /* Bars container: bottom-left, fixed width 40% for readability */
  .bars{position:absolute;left:18px;bottom:18px;width:40%;display:grid;gap:8px;pointer-events:none}
  .bar{position:relative;height:14px;background:rgba(12,12,16,.85);border:1px solid #2e2e36;overflow:hidden}
  .bar span{position:absolute;left:0;top:0;bottom:0;width:70%;transform-origin:left center;background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(0,0,0,.18)),repeating-linear-gradient(90deg,rgba(255,255,255,.06) 0 6px,transparent 6px 12px);transition:width .14s}
  .bar.hp span{background-color:var(--hp);mix-blend-mode:screen;animation:hpPulse 2.4s ease-in-out infinite}
  .bar.st span{background-color:var(--st);mix-blend-mode:screen}
  .bar.mp span{background-color:var(--mp);mix-blend-mode:screen;animation:manaWave 3.2s linear infinite}
  @keyframes hpPulse{0%,100%{filter:brightness(1)}50%{filter:brightness(1.25)}}
  @keyframes manaWave{0%{transform:translateX(-3%)}100%{transform:translateX(3%)}}

  /* Crosshair */
  #ret{position:absolute;left:50%;top:50%;width:24px;height:24px;transform:translate(-50%,-50%);pointer-events:none}
  #ret:before,#ret:after{content:"";position:absolute;inset:0;margin:auto;border-radius:50%}
  #ret:before{width:6px;height:6px;border:1px solid #ccc;opacity:.9}
  #ret:after{width:18px;height:18px;border:1px dashed rgba(255,255,255,.25)}

  /* Film */
  #grain{position:absolute;inset:-10%;pointer-events:none;background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="140" height="140"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23n)"/></svg>');opacity:.05;mix-blend-mode:screen;animation:grain 1s steps(2) infinite}
  @keyframes grain{0%{transform:translate(0,0)}25%{transform:translate(-2%,1%)}50%{transform:translate(1%,-1%)}75%{transform:translate(2%,1%)}100%{transform:translate(0,0)}}
  #scan{position:absolute;inset:0;background:linear-gradient(rgba(255,255,255,.03),rgba(0,0,0,0) 2px);background-size:100% 2px;opacity:.15;pointer-events:none}
  #vig{position:absolute;inset:-2%;pointer-events:none;box-shadow:inset 0 0 180px rgba(0,0,0,.75), inset 0 0 340px rgba(0,0,0,.55)}

  /* Subtitles & toast */
  #subs{position:absolute;left:0;right:0;bottom:72px;display:grid;place-items:center;pointer-events:none;font-size:14px}
  #subs .line{background:rgba(0,0,0,.55);padding:6px 8px;border:1px solid #333;max-width:70%;text-align:center}
  #toast{position:absolute;left:50%;transform:translateX(-50%);top:18px;background:rgba(0,0,0,.55);padding:6px 8px;border:1px solid #333;display:none}

  /* Veils */
  .veil{position:absolute;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 50%, rgba(0,0,0,.55), rgba(0,0,0,.9));transition:opacity .25s}
  .panel{background:var(--ui-bg);border:1px solid #303036;padding:18px 20px;max-width:760px;box-shadow:0 12px 60px rgba(0,0,0,.5)}
  h1{margin:0 0 8px;font-size:26px;letter-spacing:1px;text-transform:uppercase}
  .btn{pointer-events:auto;display:inline-block;background:linear-gradient(180deg,#2b1013,#110708);color:#f5e3e3;border:1px solid #4a1a20;padding:10px 14px;text-transform:uppercase;letter-spacing:1px;cursor:pointer;box-shadow:0 6px 20px rgba(181,31,42,.25);transition:transform .08s,filter .15s}
  .btn:hover{filter:brightness(1.15);transform:translateY(-1px)}
  .btn.ghost{background:#141414;border-color:#333;box-shadow:none;color:#ddd}
  #pause{display:none}
  #fs{position:absolute;right:8px;bottom:8px;pointer-events:auto}
  #hurt{position:absolute;inset:0;background:radial-gradient(closest-side at 50% 50%, rgba(181,31,42,.18), rgba(181,31,42,0));opacity:0;pointer-events:none;transition:opacity .18s}
</style>
</head>
<body>
  <div id="root">
    <div id="stage">
      <canvas id="game"></canvas>
      <div id="hud">
        <div class="ornate"></div>
        <div class="bars">
          <div class="bar hp" aria-label="Health"><span id="hpFill" style="width:100%"></span></div>
          <div class="bar st" aria-label="Stamina"><span id="stFill" style="width:100%"></span></div>
          <div class="bar mp" aria-label="Mana"><span id="mpFill" style="width:100%"></span></div>
        </div>
        <div id="ret"></div>
        <div id="grain"></div>
        <div id="scan"></div>
        <div id="vig"></div>
        <div id="subs"><div class="line" id="subsLine" style="display:none"></div></div>
        <div id="toast"></div>
        <div id="hurt"></div>
      </div>

      <div id="title" class="veil">
        <div class="panel">
          <h1>ASHES OF THE UNNAMED</h1>
          <p style="opacity:.9;margin:8px 0 12px">Full CDN build (v3). Click to start; then click the game to capture the mouse.</p>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button id="startBtn" class="btn">Click to Start</button>
            <button id="howBtn" class="btn ghost">Controls</button>
            <button id="creditsBtn" class="btn ghost">Credits</button>
          </div>
        </div>
      </div>

      <div id="pause" class="veil">
        <div class="panel">
          <h2 style="margin:0 0 8px">Options</h2>
          <div style="display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center">
            <label>Master Volume</label><input id="vol" type="range" min="0" max="1" step="0.01" value="0.8"/>
            <label>FOV</label><input id="fov" type="range" min="75" max="110" step="1" value="100"/>
            <label>Mouse Sensitivity</label><input id="sens" type="range" min="0.2" max="2.0" step="0.05" value="1.0"/>
            <label>Screen Shake</label><input id="shake" type="range" min="0" max="1" step="0.01" value="0.4"/>
            <label>Chromatic Aberration</label><input id="aberr" type="range" min="0" max="1" step="0.01" value="0.2"/>
          </div>
          <div style="display:flex;justify-content:space-between;gap:8px;margin-top:10px">
            <div style="display:flex;gap:8px">
              <button id="resumeBtn" class="btn">Resume</button>
              <button id="resetRunBtn" class="btn" title="Clears local save">Reset Run</button>
            </div>
            <button id="toTitleBtn" class="btn ghost">Quit to Title</button>
          </div>
        </div>
      </div>

      <button id="fs" class="btn" title="Toggle Fullscreen">Fullscreen</button>
    </div>
  </div>

  <script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
import { PointerLockControls } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/controls/PointerLockControls.js";

    // ---------- DOM refs ----------
    const stage = document.getElementById('stage');
    const canvas = document.getElementById('game');
    const title = document.getElementById('title');
    const pause = document.getElementById('pause');
    const hurt = document.getElementById('hurt');
    const hud = {
      hp: document.getElementById('hpFill'),
      st: document.getElementById('stFill'),
      mp: document.getElementById('mpFill'),
      toast: document.getElementById('toast'),
      subs: document.getElementById('subsLine'),
    };
    const btn = {
      start: document.getElementById('startBtn'),
      how: document.getElementById('howBtn'),
      credits: document.getElementById('creditsBtn'),
      fs: document.getElementById('fs'),
      resume: document.getElementById('resumeBtn'),
      reset: document.getElementById('resetRunBtn'),
      toTitle: document.getElementById('toTitleBtn'),
    };
    const opt = {
      vol: document.getElementById('vol'),
      fov: document.getElementById('fov'),
      sens: document.getElementById('sens'),
      shake: document.getElementById('shake'),
      aberr: document.getElementById('aberr'),
    };

    // ---------- Renderer / Scene ----------
    let WIDTH = stage.clientWidth, HEIGHT = stage.clientHeight;
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:false, alpha:false, powerPreference:'high-performance' });
    renderer.setSize(WIDTH, HEIGHT, false);
    renderer.setPixelRatio(1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.BasicShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);
    scene.fog = new THREE.FogExp2(0x0b0b10, 0.04);

    const camera = new THREE.PerspectiveCamera(parseFloat(opt.fov.value), WIDTH/HEIGHT, 0.1, 200);
    camera.position.set(-18, 1.6, -10);

    const controls = new PointerLockControls(camera, stage);
    let pointerLocked=false;
    stage.addEventListener('click', ()=>{ if(!pointerLocked) controls.lock(); });
    controls.addEventListener('lock', ()=> pointerLocked=true);
    controls.addEventListener('unlock', ()=> pointerLocked=false);

    // utility
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function bar(el,cur,max){ el.style.width = clamp(Math.round((cur/max)*100),0,100)+'%'; }

    // ---------- Procedural textures ----------
    function makeTexture(w,h,paint){
      const c = document.createElement('canvas'); c.width=w; c.height=h;
      const g = c.getContext('2d'); paint(g,w,h);
      const t = new THREE.CanvasTexture(c);
      t.minFilter = THREE.NearestFilter; t.magFilter = THREE.NearestFilter; t.generateMipmaps=false; t.needsUpdate=true;
      return t;
    }
    const texStone = makeTexture(256,256,(g,w,h)=>{
      g.fillStyle='#191a1d'; g.fillRect(0,0,w,h);
      for(let i=0;i<260;i++){ const x=Math.random()*w,y=Math.random()*h,r=2+Math.random()*4; g.fillStyle=`rgba(255,255,255,${Math.random()*0.08})`; g.beginPath(); g.arc(x,y,r,0,6.28); g.fill();}
    });
    const texBrick = makeTexture(256,256,(g,w,h)=>{
      g.fillStyle='#2a2426'; g.fillRect(0,0,w,h);
      for(let y=0;y<h;y+=24){
        for(let x=((y/24)%2)*18;x<w;x+=36){
          g.fillStyle='#3a3234'; g.fillRect(x+1,y+1,34,22);
          g.fillStyle='#473e40'; g.fillRect(x+2,y+2,32,20);
          g.fillStyle='rgba(0,0,0,.25)'; g.fillRect(x+2,y+20,32,2);
        }
      }
    });
    const texWood = makeTexture(256,256,(g,w,h)=>{
      g.fillStyle='#2a221a'; g.fillRect(0,0,w,h);
      for(let i=0;i<14;i++){ const y=i*(h/14); g.fillStyle='#3b2f22'; g.fillRect(0,y+1,w,(h/14)-2); g.fillStyle='rgba(0,0,0,.2)'; g.fillRect(0,y+(h/14)-3,w,2); }
      g.strokeStyle='rgba(255,255,255,.05)';
      for(let i=0;i<50;i++){ g.beginPath(); g.moveTo(0,Math.random()*h); g.bezierCurveTo(w*.3,Math.random()*h, w*.6,Math.random()*h, w,Math.random()*h); g.stroke(); }
    });
    const texFlesh = makeTexture(256,256,(g,w,h)=>{
      const grd=g.createLinearGradient(0,0,w,h); grd.addColorStop(0,'#5a2424'); grd.addColorStop(1,'#2b0f0f'); g.fillStyle=grd; g.fillRect(0,0,w,h);
      for(let i=0;i<180;i++){ g.fillStyle=`rgba(255,120,120,${Math.random()*0.15})`; g.beginPath(); g.ellipse(Math.random()*w,Math.random()*h,6+Math.random()*16,2+Math.random()*6,Math.random()*3.14,0,6.28); g.fill(); }
    });
    const matStone = new THREE.MeshLambertMaterial({ map: texStone });
    const matBrick = new THREE.MeshLambertMaterial({ map: texBrick });
    const matWood  = new THREE.MeshLambertMaterial({ map: texWood });
    const matFlesh = new THREE.MeshLambertMaterial({ map: texFlesh, emissive:new THREE.Color(0x220000), emissiveIntensity:0.2 });

    // ---------- Animated sprite sheets (procedural) ----------
    function makeSpriteSheet(w,h,frames,paintFrame){
      const c=document.createElement('canvas'); c.width=w*frames; c.height=h;
      const g=c.getContext('2d');
      for(let i=0;i<frames;i++){ paintFrame(g,w,h,i,frames); }
      const t=new THREE.CanvasTexture(c); t.minFilter=THREE.NearestFilter; t.magFilter=THREE.NearestFilter; t.wrapS=THREE.ClampToEdgeWrapping; t.wrapT=THREE.ClampToEdgeWrapping; t.needsUpdate=true;
      return {tex:t, w, h, frames};
    }
    // ember puff
    const emberSheet = makeSpriteSheet(32,32,6,(g,w,h,i,f)=>{
      const cx=w*i, r=6+i*3;
      g.save(); g.translate(cx+w/2,h/2);
      g.fillStyle='rgba(212,87,42,0.25)'; g.beginPath(); g.arc(0,0,r+4,0,6.28); g.fill();
      g.fillStyle='rgba(255,160,70,0.6)'; g.beginPath(); g.arc(0,0,r,0,6.28); g.fill();
      g.fillStyle='rgba(255,230,160,0.4)'; g.beginPath(); g.arc(0,0,r*.5,0,6.28); g.fill();
      g.restore();
    });
    // slash arc
    const slashSheet = makeSpriteSheet(64,64,5,(g,w,h,i,f)=>{
      const cx=w*i; g.save(); g.translate(cx+w/2,h/2);
      g.strokeStyle='rgba(255,255,255,.35)'; g.lineWidth=3;
      g.beginPath(); g.arc(0,0,20+i*3, -1.2, 0.3); g.stroke();
      g.strokeStyle='rgba(181,31,42,.7)'; g.lineWidth=2;
      g.beginPath(); g.arc(0,0,18+i*3, -1.2, 0.3); g.stroke();
      g.restore();
    });
    // wraith flicker
    const wraithSheet = makeSpriteSheet(40,56,6,(g,w,h,i,f)=>{
      const cx=w*i;
      g.fillStyle=`rgba(120,160,180,${.35 + Math.sin(i)*.2})`;
      g.fillRect(cx+10,8,20,40);
      g.fillStyle='rgba(255,255,255,.25)'; g.fillRect(cx+14,20,4,6); g.fillRect(cx+22,20,4,6);
    });
    // hound run (abstract)
    const houndSheet = makeSpriteSheet(48,32,6,(g,w,h,i,f)=>{
      const cx=w*i;
      g.fillStyle='#333'; g.fillRect(cx+6,12,28,10);
      g.fillStyle='#222'; g.fillRect(cx+28,8,10,6);
      const phase = i%2;
      g.fillStyle='#111';
      g.fillRect(cx+10,22,6,4); g.fillRect(cx+22,22,6,4);
      if(phase){ g.fillRect(cx+16,24,6,4); g.fillRect(cx+28,24,6,4); }
    });

    function makeSpriteMaterial(sheet){
      const mat = new THREE.SpriteMaterial({ map: sheet.tex, transparent:true });
      return {mat, sheet, frame:0, t:0, rate:0.06};
    }
    function updateSpriteAnim(anim, dt){
      anim.t += dt;
      if(anim.t>anim.rate){
        anim.t=0; anim.frame=(anim.frame+1)%anim.sheet.frames;
        const u = 1/anim.sheet.frames;
        anim.mat.map.offset.set(u*anim.frame, 0);
        anim.mat.map.repeat.set(u, 1);
        anim.mat.map.needsUpdate=true;
      }
    }

    // ---------- Lights ----------
    const amb = new THREE.AmbientLight(0x222222, 1.4); scene.add(amb);
    const fireLight = new THREE.PointLight(0xff4a22, 2, 18); fireLight.position.set(0,3,0); scene.add(fireLight);
    function updateFireLight(t){
      fireLight.intensity = 1.7 + Math.sin(t*9.3)*0.2 + Math.sin(t*14.7)*0.15;
    }

    // ---------- World ----------
    const world = new THREE.Group(); scene.add(world);
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(200,200,4,4), matStone);
    floor.rotation.x = -Math.PI/2; floor.receiveShadow=true; world.add(floor);

    function addBlock(x,z,w,d,h,mat){
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
      mesh.position.set(x, h/2, z); mesh.castShadow=true; mesh.receiveShadow=true; world.add(mesh);
      return mesh;
    }
    function buildTown(){
      for(let i=0;i<10;i++) addBlock(-20+i*4,-10,3,3,4+Math.random()*2,matBrick);
      for(let i=0;i<12;i++){ addBlock(-10+i*3,-2,2.5,2.5,6+Math.random()*3,matBrick); if(i%3===0) addBlock(-10+i*3,4,2,2,6,matWood); }
      addBlock(18,-4,4,4,14,matBrick); // bell
      for(let i=0;i<6;i++){ addBlock(38+i*4,-6,3,3,8,matStone); addBlock(38+i*4,6,3,3,8,matStone); }
      const pad = new THREE.Mesh(new THREE.CylinderGeometry(4,4,.7,16), matStone); pad.position.set(52,.35,0); pad.receiveShadow=true; world.add(pad);
    }
    buildTown();

    // ambient embers (animated sprites)
    const emberSprites=[];
    for(let i=0;i<18;i++){
      const anim=makeSpriteMaterial(emberSheet);
      const s=new THREE.Sprite(anim.mat); s.position.set(-8+Math.random()*50, 1+Math.random()*6, -6+Math.random()*12); s.scale.set(1.2,1.2,1);
      world.add(s); emberSprites.push({s,anim,vy:.3+Math.random()*0.6});
    }

    // ---------- Shrines ----------
    const shrines=[];
    function makeShrine(x,z){
      const s = new THREE.Mesh(new THREE.CylinderGeometry(0.8,1.2,1.2,12), new THREE.MeshLambertMaterial({color:0x444466}));
      s.position.set(x,0.6,z); s.castShadow=true; world.add(s);
      // glow sprite
      const anim=makeSpriteMaterial(emberSheet); anim.rate=0.09;
      const glow=new THREE.Sprite(anim.mat); glow.position.set(x,1.4,z); glow.scale.set(2,2,1); world.add(glow);
      shrines.push({mesh:s, glow, anim});
      return s;
    }
    makeShrine(-12,-6); makeShrine(8,-2); makeShrine(36,2);

    // ---------- Player ----------
    const player = { hp:100, st:100, mp:60, maxHp:100, maxSt:100, maxMp:60, onGround:false, vel:new THREE.Vector3(), parryWindow:0, iFrames:0, lastShrine:0 };
    const keys={};
    window.addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='Escape') togglePause(true); });
    window.addEventListener('keyup', e=> keys[e.code]=false);

    // ---------- Audio ----------
    const audio = { ctx:null, master:null, vol:parseFloat(opt.vol.value), ready:false };
    function initAudio(){ if(audio.ready) return; audio.ctx=new (window.AudioContext||window.webkitAudioContext)(); audio.master=audio.ctx.createGain(); audio.master.gain.value=audio.vol; audio.master.connect(audio.ctx.destination); audio.ready=true; }
    opt.vol.addEventListener('input', ()=>{ audio.vol=parseFloat(opt.vol.value); if(audio.master) audio.master.gain.value=audio.vol; });
    function tone({f=220,t=.06,type='square',v=.2}){ if(!audio.ready) return; const o=audio.ctx.createOscillator(); o.type=type; o.frequency.value=f; const g=audio.ctx.createGain(); g.gain.value=v; o.connect(g); g.connect(audio.master); o.start(); g.gain.setValueAtTime(v,audio.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001,audio.ctx.currentTime+t); o.stop(audio.ctx.currentTime+t+.02); }
    const sfx={ step:()=>tone({f:120,t:.03,v:.06,type:'triangle'}), hit:()=>tone({f:90,t:.08,v:.2,type:'square'}), parry:()=>{tone({f:640,t:.07,v:.2,type:'sawtooth'});tone({f:860,t:.07,v:.2,type:'triangle'})}, cast:()=>tone({f:300,t:.09,v:.18,type:'sawtooth'}), riposte:()=>tone({f:200,t:.14,v:.25,type:'square'}), shrine:()=>tone({f:520,t:.2,v:.2,type:'triangle'}), bossHit:()=>tone({f:60,t:.12,v:.28,type:'square'}) };

    // ---------- Particles / feedback ----------
    const sprites=[];
    function spawnSlash(pos){
      const anim=makeSpriteMaterial(slashSheet); anim.rate=0.04;
      const s=new THREE.Sprite(anim.mat); s.position.copy(pos); s.scale.set(1.4,1.4,1); scene.add(s);
      sprites.push({s,anim,ttl:.25});
    }
    function spawnHit(pos){
      const anim=makeSpriteMaterial(emberSheet); const s=new THREE.Sprite(anim.mat); s.position.copy(pos); s.scale.set(.9,.9,1); scene.add(s);
      sprites.push({s,anim,ttl:.35});
    }

    // ---------- Enemies & Boss ----------
    const enemies=[];     // <-- single declaration (fixed)
    function makeBillboard(sheet, x,y,z, scaleX, scaleY){
      const anim=makeSpriteMaterial(sheet);
      const sp=new THREE.Sprite(anim.mat); sp.position.set(x,y,z); sp.scale.set(scaleX,scaleY,1); scene.add(sp);
      return {sp, anim};
    }
    function makeEnemy(type,x,z){
      if(type==='wraith'){
        const bb=makeBillboard(wraithSheet, x,1.6,z, 1.2,1.6);
        return { type, bb, hp:40, speed:3.2, cd:0, dead:false, stagger:0, teleportCd:0 };
      }
      if(type==='hound'){
        const bb=makeBillboard(houndSheet, x,1.0,z, 1.4,1.0);
        return { type, bb, hp:20, speed:6.4, cd:0, dead:false, stagger:0 };
      }
      const h = type==='templar'?1.6:1.4;
      const mat = (type==='templar')? new THREE.MeshLambertMaterial({color:0x222222, emissive:0x111111}) : new THREE.MeshLambertMaterial({color:0x333333});
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(.8,h,.8), mat);
      mesh.position.set(x,h/2,z); mesh.castShadow=true; mesh.receiveShadow=true; world.add(mesh);
      return { type, mesh, hp:(type==='templar'?70:40), speed:(type==='squire'?3.2:3), cd:0, dead:false, stagger:0, shield:(type==='templar'?1.0:0.0) };
    }
    function spawnWave(){
      enemies.push(makeEnemy('squire', -10,-8));
      enemies.push(makeEnemy('archer', -4,-2));
      enemies.push(makeEnemy('hound',   3,-2));
      enemies.push(makeEnemy('wraith', 26,-2));
      enemies.push(makeEnemy('templar', 14,-3));
    }
    spawnWave();

    const boss={ mesh:null, hp:320, maxHp:320, phase:1, cd:3, dead:false, active:false, cystPulse:0 };
    function buildBoss(){
      const m=new THREE.Mesh(new THREE.BoxGeometry(4,6,3), matFlesh); m.position.set(52,3,0); m.castShadow=true; world.add(m); boss.mesh=m;
    }
    buildBoss();

    // Projectiles
    const projectiles=[]; // <-- single declaration (fixed)
    function shoot(from, dir, speed, dmg, owner='player'){
      const geo=new THREE.SphereGeometry(.12,8,8);
      const mat=new THREE.MeshBasicMaterial({color: owner==='player'?0x88ff88:0xff8844});
      const p=new THREE.Mesh(geo,mat); p.position.copy(from); world.add(p);
      projectiles.push({mesh:p, vel:dir.multiplyScalar(speed), dmg, ttl:3.5, owner});
    }

    // Combat
    let attackCd=0, heavyHold=0;
    function tryAttack(){
      if(attackCd>0 || player.st<=0) return;
      const isHeavy = heavyHold>0.22;
      const range = isHeavy? 2.2 : 1.6;
      const dmg = isHeavy? 38 : 18;
      const dir=new THREE.Vector3(); camera.getWorldDirection(dir);
      spawnSlash(camera.position.clone().addScaledVector(dir,.9));
      for(const e of enemies){
        if(e.dead) continue;
        const epos = e.mesh? e.mesh.position : e.bb.sp.position;
        const to = epos.clone().sub(camera.position);
        const ahead = dir.dot(to.clone().normalize());
        const dist = to.length();
        if(ahead>0.8 && dist<range){
          let actual=dmg;
          if(e.type==='templar' && e.shield>0 && !(player.parryWindow>0)) actual*=0.25;
          e.hp -= actual; e.stagger = 0.4; spawnHit(epos);
          if(e.hp<=0){ e.dead=true; if(e.mesh) e.mesh.visible=false; else e.bb.sp.visible=false; }
        }
      }
      if(boss.active && !boss.dead){
        const toB = boss.mesh.position.clone().sub(camera.position);
        const ahead = dir.dot(toB.clone().normalize());
        const dist = toB.length();
        if(ahead>0.8 && dist<2.9){
          boss.hp -= isHeavy? 28:12; spawnHit(boss.mesh.position.clone().addY(-1));
          if(boss.hp<=0){ boss.dead=true; triggerEnding(); }
          else if(boss.phase===1 && boss.hp<boss.maxHp*0.5){ boss.phase=2; showSub("A choir-scream splits the air. Cysts throb."); }
        }
      }
      attackCd = isHeavy? .6 : .28;
      player.st = Math.max(0, player.st - (isHeavy?16:8));
      heavyHold=0;
    }
    function tryParry(){ if(player.st<8) return; player.parryWindow=.15; flashParry(); }
    function flashParry(){ hurt.style.background='radial-gradient(closest-side at 50% 50%, rgba(170,220,255,.22), rgba(170,220,255,0))'; hurt.style.opacity=1; setTimeout(()=>{hurt.style.opacity=0; hurt.style.background='radial-gradient(closest-side at 50% 50%, rgba(181,31,42,.18), rgba(181,31,42,0))';},140); }

    // UI helpers
    function showToast(msg,t=2){ hud.toast.textContent=msg; hud.toast.style.display='block'; setTimeout(()=>hud.toast.style.display='none', t*1000); }
    function showSub(msg,t=2){ hud.subs.textContent=msg; hud.subs.style.display='block'; setTimeout(()=>hud.subs.style.display='none', t*1000); }

    // Save
    const SAVE_KEY="ashes_full_cdn_v3";
    function save(){ localStorage.setItem(SAVE_KEY, JSON.stringify({shrine:player.lastShrine,hp:player.hp,st:player.st,mp:player.mp})); }
    function load(){ const raw=localStorage.getItem(SAVE_KEY); if(!raw) return; try{ const d=JSON.parse(raw); player.lastShrine=d.shrine||0; const s=shrines[player.lastShrine]||shrines[0]; camera.position.set(s.mesh.position.x,1.6,s.mesh.position.z+1.4); Object.assign(player,{hp:d.hp||100,st:d.st||100,mp:d.mp||60}); }catch(e){} }

    // Start/Pause
    let running=false, paused=false, lastTime=0;
    async function startGame(){ title.style.opacity=0; setTimeout(()=>title.style.display='none',250); initAudio(); try{ await audio.ctx.resume?.(); }catch(e){}; stage.focus(); stage.click(); load(); lastTime=performance.now()/1000; running=true; animate(); showSub("The bells are silent. Ash chokes the streets."); }
    function togglePause(show){ if(!running) return; if(show){ paused=true; pause.style.display='grid'; pause.style.opacity=1; } else { paused=false; pause.style.opacity=0; setTimeout(()=>pause.style.display='none',250);} }
    function quitToTitle(){ paused=false; running=false; pause.style.display='none'; title.style.display='grid'; title.style.opacity=1; }

    btn.start.addEventListener('click', startGame);
    btn.how.addEventListener('click', ()=>alert("Controls:\nWASD move, Mouse look, Shift sprint, Space jump/dodge, LMB light/heavy (hold), RMB parry, E Eldritch Bolt, Q Grave Lance, R heal, Tab wheel, Esc pause."));
    btn.credits.addEventListener('click', ()=>alert("Ashes of the Unnamed â€” Full CDN build (v3)\nDesign & Code: Placeholder\nEngine: Three.js\nAll procedural art."));
    btn.resume?.addEventListener('click', ()=>togglePause(false));
    btn.reset?.addEventListener('click', ()=>{ localStorage.removeItem(SAVE_KEY); showToast("Run reset"); });
    btn.toTitle?.addEventListener('click', quitToTitle);
    btn.fs.addEventListener('click', ()=>{ if(document.fullscreenElement) document.exitFullscreen(); else stage.requestFullscreen().catch(()=>{}); });

    opt.fov.addEventListener('input', ()=>{ camera.fov=parseFloat(opt.fov.value); camera.updateProjectionMatrix(); });

    // Movement & inputs
    const UP=new THREE.Vector3(0,1,0);
    const grav=16, jumpV=5.8;
    const walkSpeed=4.4, sprintSpeed=7.4, airControl=0.35;
    let stepAccum=0;
    function movePlayer(dt){
      const forward=new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
      const right=new THREE.Vector3().crossVectors(forward,UP).negate();
      let wish=new THREE.Vector3();
      if(keys["KeyW"]) wish.add(forward);
      if(keys["KeyS"]) wish.add(forward.clone().negate());
      if(keys["KeyA"]) wish.add(right.clone().negate());
      if(keys["KeyD"]) wish.add(right);
      if(wish.lengthSq()>0) wish.normalize();
      const sprinting=keys["ShiftLeft"] && player.st>5;
      const maxSpd=sprinting? sprintSpeed : walkSpeed;
      const accel=player.onGround? 28 : 10;
      const control=player.onGround? 1.0 : airControl;
      const currentSpd = player.vel.dot(wish);
      let add = maxSpd - currentSpd;
      if(add>0){ const accelAmt = Math.min(accel*dt*maxSpd, add) * control; player.vel.addScaledVector(wish,accelAmt); }
      player.vel.y -= grav*dt;
      if(keys["Space"]){ if(player.onGround){ player.vel.y=jumpV; player.onGround=false; player.st=Math.max(0,player.st-12); keys["Space"]=false; } }
      camera.position.addScaledVector(player.vel, dt);
      if(camera.position.y<=1.6){ camera.position.y=1.6; player.vel.y=0; if(!player.onGround) stepAccum=0; player.onGround=true; } else player.onGround=false;
      if(player.onGround){ player.vel.x*=.85; player.vel.z*=.85; const v=Math.hypot(player.vel.x,player.vel.z); stepAccum+=v*dt; if(stepAccum>2.2){ tone({f:120,t:.03,v:.06,type:'triangle'}); stepAccum=0; } } else { player.vel.x*=.995; player.vel.z*=.995; }
      if(!sprinting) player.st = Math.min(player.maxSt, player.st + (player.onGround?18:10)*dt);
      player.mp = Math.min(player.maxMp, player.mp + 8*dt);
      camera.position.x = clamp(camera.position.x,-30,64); camera.position.z = clamp(camera.position.z,-18,18);
      bar(hud.hp, player.hp, player.maxHp); bar(hud.st, player.st, player.maxSt); bar(hud.mp, player.mp, player.maxMp);
    }

    window.addEventListener('mousedown', e=>{ if(paused||!running) return; if(e.button===0){ heavyHold=0.0001; } else if(e.button===2){ tryParry(); } });
    window.addEventListener('mouseup', e=>{ if(paused||!running) return; if(e.button===0){ tryAttack(); } });
    window.addEventListener('keydown', e=>{
      if(e.code==='Escape'){ togglePause(true); return; }
      keys[e.code]=true;
      if(paused||!running) return;
      if(e.code==='KeyE'){ if(player.mp>=8){ const dir=new THREE.Vector3(); camera.getWorldDirection(dir); const from=camera.position.clone().addScaledVector(dir,.7).add(new THREE.Vector3(0,-.2,0)); shoot(from,dir,18,16,'player'); player.mp-=8; } else showToast("Out of mana");}
      if(e.code==='KeyQ'){ if(player.mp>=16){ const dir=new THREE.Vector3(); camera.getWorldDirection(dir); for(let i=0;i<3;i++){ const d=dir.clone(); d.x+=(Math.random()-.5)*.06; d.y+=(Math.random()-.5)*.06; d.z+=(Math.random()-.5)*.06; d.normalize(); const from=camera.position.clone().addScaledVector(d,.7).add(new THREE.Vector3(0,-.2,0)); shoot(from,d,22,12,'player'); } player.mp-=16; } else showToast("Out of mana");}
      if(e.code==='KeyR'){ if(player.hp<player.maxHp){ player.hp=Math.min(player.maxHp, player.hp+35); showToast("Tincture consumed"); } }
      if(e.code==='Tab'){ e.preventDefault(); showToast("Wheel: (placeholder) â€” swaps spells/consumables"); }
    }, false);
    window.addEventListener('keyup', e=>{ keys[e.code]=false; }, false);

    // Enemy AI
    function updateEnemies(dt){
      const ppos=camera.position;
      for(const e of enemies){
        if(e.dead) continue;
        const pos = e.mesh? e.mesh.position : e.bb.sp.position;
        const toP=new THREE.Vector3().subVectors(ppos,pos);
        const dist=toP.length();
        if(e.stagger>0){ e.stagger-=dt; continue; }
        if(e.type==='archer'){
          e.cd-=dt;
          if(dist>6) pos.addScaledVector(toP.setLength( 3.2*.4*dt), 1);
          else if(dist<4) pos.addScaledVector(toP.setLength(-3.2*.6*dt),1);
          if(e.cd<=0 && dist<16){ const dir=new THREE.Vector3().subVectors(ppos,pos).setLength(14); shoot(pos.clone().add(new THREE.Vector3(0,.6,0)), dir, 1, 10, 'enemy'); e.cd=2.2; }
        } else if(e.type==='wraith'){
          e.bb.anim.rate=0.05; e.teleportCd=(e.teleportCd||0)-dt;
          if(e.teleportCd<=0 && dist>6){ const dir=toP.clone().setLength(Math.max(2,dist-3)); pos.add(dir); e.teleportCd=2.6; }
          else { pos.addScaledVector(toP.setLength(3.2*dt),1); }
        } else if(e.type==='hound'){
          e.bb.anim.rate=0.04;
          pos.addScaledVector(toP.setLength(6.4*dt),1);
          e.cd-=dt;
          if(e.cd<=0 && dist<1.6){ if(player.iFrames<=0){ player.hp-=10; damageFlash(); if(player.hp<=0) onPlayerDeath(); } e.cd=1.0; }
        } else {
          pos.addScaledVector(toP.setLength(3.2*dt),1);
          e.cd-=dt;
          if(e.cd<=0 && dist<1.6){
            if(player.parryWindow>0){ e.stagger=1.2; e.hp-=28; spawnHit(pos.clone()); if(e.hp<=0){ e.dead=true; if(e.mesh) e.mesh.visible=false; } }
            else if(player.iFrames<=0){ player.hp -= (e.type==='templar'?18:10); damageFlash(); if(player.hp<=0) onPlayerDeath(); }
            e.cd=1.2;
          }
        }
        if(e.mesh) e.mesh.position.copy(pos); else e.bb.sp.position.copy(pos);
      }
    }

    // Boss AI
    function updateBoss(dt){
      if(boss.dead) return;
      const p=camera.position, b=boss.mesh.position, dist=p.distanceTo(b);
      if(dist<14) boss.active=true;
      if(!boss.active) return;
      boss.cd-=dt;
      boss.mesh.position.y = 3 + Math.sin(performance.now()/500)*0.2;
      if(boss.cd<=0){
        if(boss.phase===1){
          if(Math.random()<0.6){ if(dist<3.6 && player.iFrames<=0){ player.hp-=22; damageFlash(); if(player.hp<=0) onPlayerDeath(); } showSub("The Congregation slams the stones."); boss.cd=2.8; }
          else { for(let i=0;i<3;i++){ const dir=new THREE.Vector3().subVectors(p,b).normalize(); dir.x+=(Math.random()-.5)*.2; dir.y+=(Math.random()-.5)*.1; dir.z+=(Math.random()-.5)*.2; dir.normalize(); shoot(b.clone().add(new THREE.Vector3(0,1.5,0)), dir, 10, 14, 'enemy'); } boss.cd=3.2; }
        } else {
          if(Math.random()<0.5){ enemies.push(makeEnemy('hound', b.x+(Math.random()*2-1)*3, b.z+(Math.random()*2-1)*3)); showSub("Crawling forms spill from the choir pit."); boss.cd=2.5; }
          else { if(dist<4.2 && player.iFrames<=0){ player.hp-=26; damageFlash(); } setTimeout(()=>{ if(camera.position.distanceTo(b)<4.2 && player.iFrames<=0){ player.hp-=26; damageFlash(); } },300); setTimeout(()=>{ if(camera.position.distanceTo(b)<4.2 && player.iFrames<=0){ player.hp-=26; damageFlash(); } showSub("Weakpoint exposed!"); },600); boss.cd=4.0; }
        }
      }
    }

    // Projectiles & sprites update
    function updateProjectiles(dt){
      for(let i=projectiles.length-1;i>=0;i--){
        const p=projectiles[i]; p.mesh.position.addScaledVector(p.vel,dt); p.ttl-=dt; let hit=false;
        if(p.owner==='player'){
          for(const e of enemies){ if(e.dead) continue; const epos=e.mesh? e.mesh.position : e.bb.sp.position; if(epos.distanceTo(p.mesh.position)<0.9){ e.hp-=p.dmg; e.stagger=.2; hit=true; spawnHit(epos); if(e.hp<=0){ e.dead=true; if(e.mesh) e.mesh.visible=false; else e.bb.sp.visible=false; } break; } }
          if(boss.active&&!boss.dead && boss.mesh.position.distanceTo(p.mesh.position)<2.6){ boss.hp-=p.dmg*.6; hit=true; spawnHit(boss.mesh.position.clone().addY(-1)); if(boss.hp<=0){ boss.dead=true; triggerEnding(); } }
        } else {
          if(camera.position.distanceTo(p.mesh.position)<1.0 && player.iFrames<=0){ player.hp-=p.dmg*.7; hit=true; damageFlash(); if(player.hp<=0) onPlayerDeath(); }
        }
        if(hit||p.ttl<=0){ world.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose(); projectiles.splice(i,1); }
      }
      // update transient sprites
      for(let i=sprites.length-1;i>=0;i--){
        const o=sprites[i]; o.ttl-=dt; updateSpriteAnim(o.anim,dt); if(o.ttl<=0){ scene.remove(o.s); sprites.splice(i,1); }
      }
      // shrine glows
      for(const s of shrines){ updateSpriteAnim(s.anim, dt); }
      // embers
      for(const e of emberSprites){ updateSpriteAnim(e.anim,dt); e.s.position.y += e.vy*dt; if(e.s.position.y>6.5) e.s.position.y=1.0; }
    }

    function damageFlash(){ hurt.style.opacity=.9; setTimeout(()=>hurt.style.opacity=0, 120); }

    // Shrines
    function updateShrines(){
      for(let i=0;i<shrines.length;i++){
        const s=shrines[i];
        if(camera.position.distanceTo(s.mesh.position)<1.6){
          if(player.lastShrine!==i){ player.lastShrine=i; sfx.shrine?.(); showToast("Shrine kindled (checkpoint)."); save(); }
        }
      }
    }

    function onPlayerDeath(){
      player.hp=player.maxHp; player.st=player.maxSt; player.mp=player.maxMp;
      const s=shrines[player.lastShrine]||shrines[0];
      camera.position.set(s.mesh.position.x,1.6,s.mesh.position.z+1.2);
      showToast("You fall into ash. Shrine rekindled."); save();
    }

    // Ending
    function triggerEnding(){
      alert("The Cold Cathedral\nYou awaken in silence, cradling the king's body.\nThe Unnamed murmurs.\n(Press OK to roll credits)");
      alert("Credits:\nDesign/Code: Placeholder\nEngine: Three.js");
      quitToTitle();
    }

    // Resize
    function onResize(){ WIDTH=stage.clientWidth; HEIGHT=stage.clientHeight; renderer.setSize(WIDTH,HEIGHT,false); camera.aspect=WIDTH/HEIGHT; camera.updateProjectionMatrix(); }
    new ResizeObserver(onResize).observe(stage);

    // Post-FX (cheap)
    let aberration=parseFloat(opt.aberr.value);
    opt.aberr.addEventListener('input', ()=> aberration=parseFloat(opt.aberr.value));
    function postFx(){
      camera.projectionMatrix.elements[8]=(Math.random()*2-1)*0.0008*aberration;
      camera.projectionMatrix.elements[9]=(Math.random()*2-1)*0.0008*aberration;
    }

    // Main loop
    function animate(){
      if(!running) return;
      const now=performance.now()/1000, dt=Math.min(.033, now-lastTime); lastTime=now;
      if(paused){ requestAnimationFrame(animate); return; }
      attackCd=Math.max(0,attackCd-dt); player.parryWindow=Math.max(0,player.parryWindow-dt); player.iFrames=Math.max(0,player.iFrames-dt); if(heavyHold>0) heavyHold+=dt;
      movePlayer(dt); updateShrines(); updateEnemies(dt); updateBoss(dt); updateProjectiles(dt); updateFireLight(now); postFx();
      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }

    // Lore
    const loreSpot=new THREE.Vector3(2,1.6,-1); let loreShown=false;
    setInterval(()=>{ if(running&&!loreShown && camera.position.distanceTo(loreSpot)<1.2){ showToast("Lore: 'The bells fell silent the night the king wept.'"); loreShown=true; } },500);

    // Initialize
    setTimeout(()=>{ player.lastShrine=0; save(); },1000);
  </script>
</body>
</html>
